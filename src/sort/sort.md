### 排序算法总结

#### 稳定性
排序算法的稳定性指的是对于值相同的数据，在经过排序算法之后，值相同的数据仍然能够保持
相对的顺序，比如
```java
int[] arr = new int[]{1,1,3,3,3,2,2,2}
sort(arr)；
/**
 * 等到排序之后还能保证第一个1在第二个1之前，同理2和3
 */
```
如果能够保证上述要求，那么就说这个排序算法是具有稳定性的，反之则不具有，其实对于基础类型而言，稳定性并没有什么太大的作用，但是对于一些非基础类型的数据
，稳定性通常有很多的应用场景，比如对于一个student类型，他其中有age,class类型，如果我先对age进行排序，那么就会从小到大排除这些学生来，然后再使用class
属性排序，如果是稳定性的排序，那么每个班级中的学生age也是拍好序的

下面将分别分析这七个排序算法是否具有稳定性

**时间复杂度为O(N^2)的排序算法**
- 选择排序：对于一个数组`arr[] = {3,3,3,3,1}`，进行选择排序的时候直接会把1和第一个3进行交换，这一下子就改变了3之间的相对顺序，于是选择排序就不能够保持稳定性了
- 冒泡排序：在进行冒泡排序的时候，如果保证相邻两个数相等时不交换顺序，那么他就能够保持稳定性
- 插入排序：同样能够保持稳定性，因为插入排序是往前看的，因此当进行插入排序时，如果保证了两个数相等时不交换数据顺序，那么插入排序也是能够保持稳定性的

**时间复杂度为O(N log N)的排序算法**

- 归并排序：再进行归并排序的时候如果两个数组的数据相等了，那么我只需要先拷贝左侧数组中的数据就能够保证算法的稳定性
- 快速排序：他是不能够保证稳定性的，因为快排在partition的过程中就不能够保证稳定性了，比如一个数组`arr[] = {5,5,5,5,3}`，当
我选择5作为划分值时，小于5的放在左边，大于5的放在右边，等于5的不动，所以直到走到3这个位置，这四个5之间的顺序是不会变化的，当走到3
之后会跟第一个5交换位置，这样一下就破坏了这四个5之间的相对顺序，因此不能够做到稳定性
- 堆排序：这个排序也不能够保证数据的稳定性，因为他是把数组中的数据弄成一个大根堆，在变成大跟堆的过程中根本没有考虑是不是稳定，比如一个数组
`arr[] = {5,4,4,6}`最开始5是一个大根堆，第一个4被放到左子树，第二个4被放到右子树，直到6来了之后，他比第一个4大，因此需要向上做heapInsert的
过程，这样就交换了6和4的位置...，因此堆排序也不能够保持稳定性

基数排序和计数排序都是能够保持稳定性的，因为他们是基于桶，数据进桶和出桶的顺序都是能够保证的，不基于比较的排序算法很容易能够做到稳定性

#### 总结
| 算法名称 |时间复杂度 | 空间复杂度 | 稳定性 |
|----|----|----| ---- |
| 选择排序 | O(N^2) | O(1) | 不稳定 |
| 冒泡排序 | O(N^2) | O(1) |  稳定  |
| 插入排序 | O(N^2) | O(1) | 稳定 |
| 归并排序 | o(N log N) | O(N) | 稳定 |
| 快速排序 | O(N log N) | O(log N)（递归栈的高度） | 不稳定 |
|  堆排序  | O(N log N) | O(1) | 不稳定 |

其实对于这几个算法，快排是最快的，如果没有空间和稳定性限制，那么尽量使用快排，
如果存在空间要求，那么使用堆排序，如果有稳定性要求，那么使用归并排序


1. 基于比较的排序目前还没有算法能够将时间复杂度降到O(N*log N)以下
2. 同时也没有算法能够在时间复杂度为O(N*log N)，空间复杂度小于O(N)的情况下保持稳定性
3. 综合排序
```java
public class example01 {
    public void quickSort(int[] arr, int L, int R) {
        if (arr.length < 2 || arr == null) {
            return;
        }

        if (R - L < 60) {
            // 进行插入排序
            return;
        }
        if (L < R) {
            swap(arr, L + (int) (Math.random() * (R - L + 1)), R);
            int[] p = partition(arr,L,R);
            quickSort(arr, L, p[0] - 1);
            quickSort(arr, p[1] + 1, R);
        }
    }
    
    public int[] partition(int[] arr, int L, int R) {
        // 返回<区的右边界和>区的左边界
    }
    
    public void swap(int[] arr, int i, int j){
        // 交换数据
    }
}
```
可以看到，在快速排序中有了插入排序，原因就是因为当数据样本特别大的时候，我们使用快速排序来进行调度，
当数据样本小于60的时候使用插入排序，虽然插入排序的时间复杂度是o(N^2)，但是当数据样本较小时，N不是瓶颈，
而且插入排序的常数项是非常小的，所以这样做既能够保证在大样本上使用快排进行调度，当数据样本小的时候使用插入排序
也能够保证程序的运行时间





![](img src = "../../image/140979ec4723e3484ef59120c58af3a.png")
